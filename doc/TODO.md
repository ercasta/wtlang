# TODO

1. (Done) Expand the summary doc (summary.md) creating one file with additional design considerations for each topic (language, target platform, compiler and tools). These design file must contain an evaluation of possible alternatives, with rationale supporting to choice of the chosen one.
2. (Done) Added a consideration about testing: review the documentation (especially language design and support tools) to take into account testing
3. (Done) Create a language tutorial to explain the language, complete with typical usage examples. The tutorial must separately address the data presentation part (page creation) from data manipulation part (functions, chains, external calls).
4. (Done) Create a first implementation of the compiler. Generate some source files and test the compilation process by running the compiler to produce actual streamlit output pages. Keep all example source files and related output, they will form the basis for testing the compiler itself
5. (Done) Start working on a first implementation of the language server to start experimenting with VSCode. The first step is updating the documentation regarding compiler tools, explaining the source code structure, that must support both the compiler and the Language Server (and going forward, more tools, such as debugger, documentation generator, etc.). Do not generate any implementation yet.
6. (Done) Based on the documentation about the compiler tool design, actually create a first implementation of the language server, with complete instructions on how to install and use it with VSCode. Also include references to VSCode / Language Server Protocol official documentation
7. (Done) Add some enrichment to current implementation. The load_csv built in function must get a table type as parameters, and in the generated code there must be consistency checks between the table definition and actually loaded dataframe. If not, an error saying the loaded file is not correct must be printed in the streamlit page. Also, show and show_edit should be built in functions, not keywords. Most important show_edit should return a table, as tables are immutable.
8. (Done) For the show and show_editable builtin functions, add the possibility to indicate filters by passing filters to the function. Filters are a new builtin type, "filter", that references a table column and can be "single" or "multi". We will have to rename the "filter" builtin function, we can rename that as "where". A list of filters will be passed to the show and show_editable builtin functions. In the generated code, appropriate streamlit single or multiselect filter will be shown over the table, keeping up to 3 filters on each row (use st.columns). The filter will allow selecting values belonging to that column of the table (drop_duplicates, to_list) Be extra careful with the table editing; filtering must be performed by splitting the dataframe in two dataframes, editing one, and concatenating them again after the edit. Be sure to update the documentation and create a new example page.
9. (Done) Work on scoping and symbol tables. The symbol table is needed to check for usage of variables not yet declared. Also, scoping must be implemented, as each page is a separate scope in terms of variables. As the language is strongly typed, we must also check for type consistency; this is also useful for autocomplete. We must also allow declaring variable without assigning a value, but declaring the type (we can use a colon notation for typing). The first step is expanding the compiler documentation, and likely the language tutorial. Remember that the next step will be to actually update not only the compiler but also the Language Server, and this also implies creating more useful and contextualized error messages, so take this into account when defining the strategy for managing symbols.
10. (Done) Actually implement the new scoping rules in the compiler and other tools
11. (Done) As the language and tools are expanding, a test suite for the tools is needed. Create a document to describe how to create a set of tests for the tools, to run after performing changes.
12. (Done) Implement some Unit, Integration an Regression test according to the defined testing strategy
13. (Done) Implement an error system for the compiler, so each error has a specific error code: for example brackets not closed, wrong types in assignment, etc. Consider this error will also have to be available to the LSP; we'll implement this part later. **Update**: Error system fully integrated into lexer, parser, and compiler. All 40+ error codes working with proper formatting. LSP updated to use new error system.
14. (Done) Complete the implementation of the LSP adding hover and autocomplete, also taking into account the new error system implemented in step 13. **Update**: LSP now provides:
    - **Hover**: Shows type information and documentation for variables, functions, tables, built-in functions, and keywords
    - **Autocomplete**: Context-aware suggestions for keywords, built-in functions, user-defined symbols (tables, functions, variables), and table field names
    - **Diagnostics**: Integrated with the error system to show error codes, proper ranges, and formatted error messages from lexer, parser, and semantic analyzer
    - **Symbol Table Integration**: Uses semantic analysis to provide accurate type information and scope-aware completions
15. (Done): Since a lot of things changed from the first implementation, perform a review of the current state of the implementation, and document the findings for further developments. **Update**: Comprehensive review completed and documented in `step15_comprehensive_review.md`. Key findings:
    - **Language Syntax**: Clean and consistent - no unnecessary complexities identified. Keywords serve distinct purposes and should remain.
    - **Compiler Architecture**: Follows multi-pass design well. Minor deviation: uses hand-written parser (not LALRPOP) and no IR/optimization pass (direct ASTâ†’code generation). Both are positive choices for current needs.
    - **Source Code Structure**: Good organization with wtlang-core, wtlang-compiler, and wtlang-lsp. Recommended minor improvements: split semantics.rs if it grows, add utils.rs, add integration tests.
    - **Documentation Alignment**: Well-aligned overall. Needs updates to compiler_tools_design.md to reflect actual parser implementation and lack of IR. Should add codegen_design.md.
    - **Examples**: All 8 examples compile successfully and demonstrate features well. Recommended additions: error handling example, advanced pipeline example, testing example.
    - **Overall Assessment**: Production-ready for core features with excellent foundation for future development.


