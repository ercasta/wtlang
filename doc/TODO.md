# TODO

1. (Done) Expand the summary doc (summary.md) creating one file with additional design considerations for each topic (language, target platform, compiler and tools). These design file must contain an evaluation of possible alternatives, with rationale supporting to choice of the chosen one.
2. (Done) Added a consideration about testing: review the documentation (especially language design and support tools) to take into account testing
3. (Done) Create a language tutorial to explain the language, complete with typical usage examples. The tutorial must separately address the data presentation part (page creation) from data manipulation part (functions, chains, external calls).
4. (Done) Create a first implementation of the compiler. Generate some source files and test the compilation process by running the compiler to produce actual streamlit output pages. Keep all example source files and related output, they will form the basis for testing the compiler itself
5. (Done) Start working on a first implementation of the language server to start experimenting with VSCode. The first step is updating the documentation regarding compiler tools, explaining the source code structure, that must support both the compiler and the Language Server (and going forward, more tools, such as debugger, documentation generator, etc.). Do not generate any implementation yet.
6. (Done) Based on the documentation about the compiler tool design, actually create a first implementation of the language server, with complete instructions on how to install and use it with VSCode. Also include references to VSCode / Language Server Protocol official documentation
7. (Done) Add some enrichment to current implementation. The load_csv built in function must get a table type as parameters, and in the generated code there must be consistency checks between the table definition and actually loaded dataframe. If not, an error saying the loaded file is not correct must be printed in the streamlit page. Also, show and show_edit should be built in functions, not keywords. Most important show_edit should return a table, as tables are immutable.
8. (Done) For the show and show_editable builtin functions, add the possibility to indicate filters by passing filters to the function. Filters are a new builtin type, "filter", that references a table column and can be "single" or "multi". We will have to rename the "filter" builtin function, we can rename that as "where". A list of filters will be passed to the show and show_editable builtin functions. In the generated code, appropriate streamlit single or multiselect filter will be shown over the table, keeping up to 3 filters on each row (use st.columns). The filter will allow selecting values belonging to that column of the table (drop_duplicates, to_list) Be extra careful with the table editing; filtering must be performed by splitting the dataframe in two dataframes, editing one, and concatenating them again after the edit. Be sure to update the documentation and create a new example page.
9. (Done) Work on scoping and symbol tables. The symbol table is needed to check for usage of variables not yet declared. Also, scoping must be implemented, as each page is a separate scope in terms of variables. As the language is strongly typed, we must also check for type consistency; this is also useful for autocomplete. We must also allow declaring variable without assigning a value, but declaring the type (we can use a colon notation for typing). The first step is expanding the compiler documentation, and likely the language tutorial. Remember that the next step will be to actually update not only the compiler but also the Language Server, and this also implies creating more useful and contextualized error messages, so take this into account when defining the strategy for managing symbols.
10. (Done) Actually implement the new scoping rules in the compiler and other tools


